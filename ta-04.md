
# Backend Technical Assessment: Junior Developer (E-Commerce Domain)

## ðŸ“˜ Problem Statement

**Business Context:**
You are joining the backend team of a fast-growing e-commerce startup. The company wants to launch a new feature: a simple product inventory management API. This API will allow admins to add, update, and view products in the catalog. The system should be robust, handle basic validation, and be ready for future scaling (e.g., microservices, caching).

**Requirements:**
- Build RESTful endpoints for managing products (CRUD: Create, Read, Update, Delete)
- Each product has: `name` (string), `price` (number), `quantity` (number), `category` (string, optional)
- Use MongoDB for data storage
- Validate input (e.g., price > 0, quantity >= 0, name required)
- Follow REST API best practices (status codes, error messages, etc.)
- Prepare for future microservices (e.g., modular code, clear separation of concerns)

---

## ðŸ§© Code Skeleton

**src/models/product.ts**
```typescript
import mongoose, { Schema, Document } from 'mongoose';

export interface IProduct extends Document {
  name: string;
  price: number;
  quantity: number;
  category?: string;
}

const ProductSchema: Schema = new Schema({
  name: { type: String, required: true },
  price: { type: Number, required: true },
  quantity: { type: Number, required: true },
  category: { type: String },
});

export default mongoose.model<IProduct>('Product', ProductSchema);
```

**src/routes/product.ts**
```typescript
import express from 'express';
import Product from '../models/product';
const router = express.Router();

// TODO: Implement POST /products (create a new product)
router.post('/products', async (req, res) => {
  // TBD: Validate input, create product, handle errors
});

// TODO: Implement GET /products (list all products)
router.get('/products', async (req, res) => {
  // TBD: Fetch products from DB, handle errors
});

// TODO: Implement GET /products/:id (get product by id)
router.get('/products/:id', async (req, res) => {
  // TBD: Fetch product by ID, handle not found
});

// TODO: Implement PUT /products/:id (update product)
router.put('/products/:id', async (req, res) => {
  // TBD: Validate input, update product, handle errors
});

// TODO: Implement DELETE /products/:id (delete product)
router.delete('/products/:id', async (req, res) => {
  // TBD: Delete product, handle errors
});

export default router;
```

**src/app.ts**
```typescript
import express from 'express';
import mongoose from 'mongoose';
import productRoutes from './routes/product';

const app = express();
app.use(express.json());

// TODO: Connect to MongoDB (use environment variable for URI)
// TBD: mongoose.connect(process.env.MONGO_URI || '', { ... })

app.use('/api', productRoutes);

// TODO: Add error handling middleware

export default app;
```

---

## âœ… Testing Expectations

- **Unit Tests (Jest):**
  - Model validation (e.g., missing name, negative price)
  - Route handler logic (mock DB calls)
- **Integration Tests:**
  - API endpoints (using supertest or similar)
  - Edge cases: invalid input, not found, duplicate products

---

## ðŸ’¡ Optional Bonus

- Implement centralized error handling middleware
- Add pagination to GET /products
- Add rate limiting (e.g., express-rate-limit)
- Integrate Redis for caching product lists
- Prepare for microservices (e.g., split routes/controllers/services)


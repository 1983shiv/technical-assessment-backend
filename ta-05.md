
# Backend Technical Assessment: Junior Developer (Fintech Domain)

## ðŸ“˜ Problem Statement

**Business Context:**
You are joining the backend team of a fintech startup building a simple digital wallet service. The company wants to launch a feature that allows users to create accounts, check their balance, and transfer funds to other users. The system should be secure, validate all inputs, and follow REST API best practices.

**Requirements:**
- Build RESTful endpoints for:
  - Creating a user account
  - Checking account balance
  - Transferring funds between users
- Use PostgreSQL for data storage
- Validate input (e.g., positive transfer amounts, sufficient balance, unique email)
- Follow REST API best practices (status codes, error messages, etc.)
- Prepare for future microservices (modular code, clear separation of concerns)

---

## ðŸ§© Code Skeleton

**src/models/user.ts**
```typescript
import { Pool } from 'pg';

export interface User {
  id: number;
  name: string;
  email: string;
  balance: number;
}

// TODO: Initialize PostgreSQL pool connection
export const pool = new Pool({
  // TBD: connection config (use env variables)
});

// TODO: Implement user model functions (create, find, update balance)
```

**src/routes/user.ts**
```typescript
import express from 'express';
import { pool } from '../models/user';
const router = express.Router();

// TODO: Implement POST /users (create account)
router.post('/users', async (req, res) => {
  // TBD: Validate input, insert user, handle errors
});

// TODO: Implement GET /users/:id/balance (get balance)
router.get('/users/:id/balance', async (req, res) => {
  // TBD: Fetch user, return balance, handle errors
});

// TODO: Implement POST /users/transfer (transfer funds)
router.post('/users/transfer', async (req, res) => {
  // TBD: Validate input, check balances, update both users, handle errors
});

export default router;
```

**src/app.ts**
```typescript
import express from 'express';
import userRoutes from './routes/user';

const app = express();
app.use(express.json());

app.use('/api', userRoutes);

// TODO: Add error handling middleware

export default app;
```

---

## âœ… Testing Expectations

- **Unit Tests (Jest):**
  - User model functions (e.g., create, find, update balance)
  - Input validation logic (e.g., negative amounts, duplicate emails)
- **Integration Tests:**
  - API endpoints (using supertest or similar)
  - Edge cases: insufficient funds, invalid user IDs, concurrent transfers

**Example Jest Test Skeleton:**
```typescript
import request from 'supertest';
import app from '../app';

describe('User API', () => {
  it('should create a new user', async () => {
    // TODO: Implement test
  });

  it('should not allow duplicate emails', async () => {
    // TODO: Implement test
  });

  it('should transfer funds between users', async () => {
    // TODO: Implement test
  });

  it('should handle insufficient funds', async () => {
    // TODO: Implement test
  });
});
```

---

## ðŸ’¡ Optional Bonus

- Implement centralized error handling middleware
- Add transaction support for transfers (atomicity)
- Add rate limiting (e.g., express-rate-limit)
- Prepare for microservices (split routes/controllers/services)
- Add audit logging for transfers

